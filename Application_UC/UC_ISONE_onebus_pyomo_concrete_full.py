
import pandas as pd
import numpy as np
import sympy as sy
import matplotlib
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from pyomo.environ import *


# Setting for plot
font = {'family' : 'Times New Roman',
        'weight' : 'normal',
        'size'   : 12}
matplotlib.rc('font', **font)


"""
Get the ISO level time-series load data from csv
This data set should be generated by modules developed by BNL
"""
# read ISO level load data
LoadData=pd.read_csv('P_Load.csv')  # pandas dataframe
LoadData_at=pd.read_csv('P_Load_at.csv')
PL_norm=LoadData.iloc[:,1] # normal, type: series
PL_at= LoadData_at.iloc[:, 1] # normal, type: series
number_hour=len(PL_norm)  # scheduling horizon



""" 
Import the studied system data using matpower/pypower format
"""
import Func_IEEETestCase as case
ppc=case.case39() # dictionary data

# calculate base
base_mva=ppc['baseMVA']     # MVA
base_KV=ppc['baseKV']       # KV
base_KA=base_mva/base_KV    # KA
base_Ohm=base_KV/base_KA    # Ohm
base_Siemens=1/base_Ohm     # Siemens

# get size of bus, line and generator
number_bus=ppc['bus'].shape[0] # shape returns (row,column)
number_gen=ppc['gen'].shape[0]

# create iterator for bus, generator and horizon
iter_bus=np.arange(0,number_bus)
iter_gen=np.arange(0,number_gen)
iter_hour=np.arange(0,number_hour)
iter_hour_1=np.arange(1,number_hour)

# Generator iterators for minimum up and down time for different generators
# Assume the hour index is: 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ... N
# Minimum up time iterator: The index t of the formulation will always start at 1, end at N-1
iter_hour_updown=np.arange(1, number_hour-1)




"""
Load data distribution
The load data (active power) is distributed according the static load data of standard IEEE 39-bus.
For now we are not sure this is the way that we want to perform our attack.
"""
# # get static load data from standard IEEE 39-bus system (unit: MW/Mvar)
# load_p=ppc['bus'][:,2]
# load_q=ppc['bus'][:,3]

Rmin_sys=0



"""
Convert the generator cost to a simplified version C=A*u + mc*delta_p
"""
p = sy.Symbol('p')
cost_curve={}
cost_curve_diff={}
cost_curve_simple={}
cost_fixed={}
cost_marginal={}
for i in iter_gen:
    cost_curve[i]=ppc["gencost"][i,1]*p**2 + ppc["gencost"][i,2]*p + ppc["gencost"][i,3]
    cost_curve_diff[i]=sy.diff(cost_curve[i],p)
    cost_fixed[i]=cost_curve[i].subs(p, ppc["gen"][i, 1])
    cost_marginal[i]=cost_curve_diff[i].subs(p,(ppc["gen"][i, 2]-ppc["gen"][i, 1])*0.5)
    cost_curve_simple[i]=cost_marginal[i]*(p-ppc["gen"][i, 1])+cost_fixed[i]



"""
Define problem in pyomo
"""
####################### Define a concrete pyomo model ####################
model = ConcreteModel()



########################## Define variables ###########################
# ! Note: Variables are defined using either iterators or sets, not total numbers
model.p1=Var(iter_gen, iter_hour, within=NonNegativeReals) # Incremental output of generator at Segment 1
model.Pg=Var(iter_gen, iter_hour, within=NonNegativeReals) # Generator total power output
model.R=Var(iter_gen, iter_hour, within=NonNegativeReals)
model.SC=Var(iter_gen, iter_hour, within=NonNegativeReals)  # Variables associated with startup cost
model.status=Var(iter_gen, iter_hour, within=Binary) # On-off status




################ Define constraints ##########################
# Constraints: generator output lower and upper bounds
def con_gen_lower(model,i,t):
    return 0<= model.p1[i,t]
model.con_gen_lower=Constraint(iter_gen, iter_hour, rule=con_gen_lower)

def con_gen_upper(model,i,t):
    return model.p1[i,t] <= (ppc["gen"][i,2]-ppc["gen"][i,1])*model.status[i, t]
model.con_gen_upper=Constraint(iter_gen, iter_hour, rule=con_gen_upper)

# generator total power output
def con_gen_total_power(model,i,t):
    return model.Pg[i,t] == model.p1[i,t] + ppc["gen"][i,1]*model.status[i, t]
model.con_gen_total_power=Constraint(iter_gen, iter_hour, rule=con_gen_total_power)

# generator reserve limit
def con_gen_reserve_1(model,i,t):
    return model.R[i,t] <= ppc["gen"][i,3]*model.status[i, t]
model.con_gen_reserve_1=Constraint(iter_gen, iter_hour, rule=con_gen_reserve_1)

def con_gen_reserve_2(model,i,t):
    return model.Pg[i,t] + model.R[i,t] <= ppc["gen"][i,2]*model.status[i, t]
model.con_gen_reserve_2=Constraint(iter_gen, iter_hour, rule=con_gen_reserve_2)

# generator ramp up (down) limit
def con_gen_ramp_up(model,i,t):
    return model.Pg[i,t]-model.Pg[i,t-1] <= ppc["gen"][i,4]*model.status[i,t-1] + ppc["gen"][i,1]*(model.status[i,t]-model.status[i,t-1])
model.con_gen_ramp_up=Constraint(iter_gen, iter_hour_1, rule=con_gen_ramp_up)

def con_gen_ramp_down(model,i,t):
    return model.Pg[i,t]-model.Pg[i,t-1] >= -ppc["gen"][i,5]*model.status[i,t] - ppc["gen"][i,1]*(model.status[i,t-1]-model.status[i,t])
model.con_gen_ramp_down=Constraint(iter_gen, iter_hour_1, rule=con_gen_ramp_down)

# network constraints: power balance
def con_balance(model,t):
    return sum(model.Pg[i,t] for i in iter_gen) == PL_norm[t]
model.con_balance=Constraint(iter_hour, rule=con_balance)

# system reserve requirement
def con_system_reserve(model,t):
    return sum(model.R[i,t] for i in iter_gen) == Rmin_sys
model.con_system_reserve=Constraint(iter_hour, rule=con_system_reserve)

# constraints associated with startup cost
def con_startup(model,i,t):
    return model.SC[i,t]>=model.status[i,t]-model.status[i,t-1]
model.con_startup=Constraint(iter_gen, iter_hour_1, rule=con_startup)

# minimum up time constraint in general time series
model.con_min_up=ConstraintList()
for i in iter_gen:
    for t in iter_hour_updown:
        for k in np.arange(1,ppc["gen"][i,8]-1):
            model.con_min_up.add( model.status[i,t]-model.status[i,t-1] <= model.status[i,min(t+k,number_hour-1)] )

# minimum up time constraint in initial condition when status[i,0]=1
model.con_min_up_initial = ConstraintList()
for i in iter_gen:
    for k in np.arange(1, ppc["gen"][i,8]-1):
            model.con_min_up_initial.add(model.status[i, 0]<= model.status[i, min(0+k, number_hour-1)])

# minimum down time constraint in general time series
model.con_min_down=ConstraintList()
for i in iter_gen:
    for t in iter_hour_updown:
        for k in np.arange(1,ppc["gen"][i,9]-1):
            model.con_min_up.add( model.status[i,t-1]-model.status[i,t] <= 1 - model.status[i,min(t+k,number_hour-1)] )

# minimum up time constraint in initial condition when status[i,0]=1
model.con_min_down_initial = ConstraintList()
for i in iter_gen:
    for k in np.arange(1, ppc["gen"][i,9]-1):
            model.con_min_down_initial.add( model.status[i, 0]<= 1 - model.status[i, min(0+k, number_hour-1)])


########################### Objective and solving the problem ###############################
def obj_gen_cost(model):
    return sum(sum(model.p1[i,t]*cost_marginal[i]         # marginal cost
                   + model.status[i, t]*cost_fixed[i]     # fixed cost
                   + model.R[i,t]*ppc["gen"][i,6]         # reserve cost
                   + model.SC[i,t]*ppc["gen"][i,7]        # startup cost
                   for t in iter_hour) for i in iter_gen)
model.obj_gen_cost=Objective(rule=obj_gen_cost)


opt = SolverFactory("glpk")
results_normal = opt.solve(model)
print(results_normal['solver'][0]['Termination condition'])


"""
Visualize the results
"""
# Export data (pyomo book 173)
# actual power output under normal case
gen_power_normal={}  # create an empty dictionary
for i in iter_gen:
    gen_power_normal[i]=[]   # create an empty list
    for h in iter_hour:
        gen_power_normal[i].append( value(model.Pg[i, h]) )

# # actual power output under attack
# gen_power_at={}  # create an empty dictionary
# for i in iter_gen:
#     gen_power_at[i]=[]   # create an empty list
#     for h in iter_hour:
#         gen_power_at[i].append(value(model_at.p1[i, h]) + value(model_at.status[i, h]) * ppc["gen"][i, 1])



# # plot
# plt.figure(figsize=(12,5))
# plt.xlabel('time (hour)')
# plt.ylabel('power (MW)')
# plt.plot(PL_norm,'b',linewidth=3,label='Normal')
# plt.plot(PL_at,'r',linestyle="--",linewidth=3,label='Attack')
# plt.title('Forcasted Load')
# plt.legend()
# plt.show()


# Plot: 2D
plt.figure(figsize=(12,5))
plt.xlabel('time (hour)')
plt.ylabel('power (MW)')
for i in range(number_gen):
    plt.step(iter_hour, gen_power_normal[i], label='Gen {}'.format(int(ppc["gen"][i, 0])), linewidth=3)
plt.title('UC under Normal Case')
plt.legend(bbox_to_anchor=(1, 1), loc=2, borderaxespad=0.5)
plt.show()


# # Plot: 3D
# fig = plt.figure(figsize=(12,5))
# ax = fig.add_subplot(111, projection='3d')
# for i in iter_gen:
#     xs = iter_hour
#     ys = gen_power_normal[i]
#     ax.bar(xs, ys, zs=int(ppc["gen"][i,0]), zdir='y', alpha=0.7, label='Gen {}'.format(int(ppc["gen"][i,0])))
# ax.set_xlabel('Hours')
# ax.set_ylabel('Generator Index')
# ax.set_zlabel('Power')
# plt.legend(bbox_to_anchor=(1, 1), loc=2, borderaxespad=0.5)
# plt.show()
# plt.title('UC under Normal Case')
#
# # Plot: 3D
# fig = plt.figure(figsize=(12,5))
# ax = fig.add_subplot(111, projection='3d')
# for i in iter_gen:
#     xs = iter_hour
#     ys = gen_power_at[i]
#     ax.bar(xs, ys, zs=int(ppc["gen"][i,0]), zdir='y', alpha=0.7, label='Gen {}'.format(int(ppc["gen"][i,0])))
# ax.set_xlabel('Hours')
# ax.set_ylabel('Generator Index')
# ax.set_zlabel('Power')
# plt.legend(bbox_to_anchor=(1, 1), loc=2, borderaxespad=0.5)
# plt.show()
# plt.title('UC under Cyber Attack')


