
import pandas as pd
import numpy as np
import sympy as sy
import matplotlib
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from pyomo.environ import *


# Setting for plot
font = {'family' : 'Times New Roman',
        'weight' : 'normal',
        'size'   : 12}
matplotlib.rc('font', **font)


"""
Get the ISO level time-series load data from csv
This data set should be generated by modules developed by BNL
"""
# read ISO level load data
LoadData=pd.read_csv('P_Load.csv')  # pandas dataframe
LoadData_at=pd.read_csv('P_Load_at.csv')
PL_norm=LoadData.iloc[:,1] # normal, type: series
PL_at= LoadData_at.iloc[:, 1] # normal, type: series
number_hour=len(PL_norm)  # scheduling horizon



""" 
Import the studied system data using matpower/pypower format
"""
import Func_IEEETestCase as case
ppc=case.case39() # dictionary data

# get size of bus, line and generator
number_bus=ppc['bus'].shape[0] # shape returns (row,column)
number_gen=ppc['gen'].shape[0]

# create iterator for bus, generator and horizon
iter_bus=np.arange(0,number_bus)
iter_gen=np.arange(0,number_gen)
iter_hour=np.arange(0,number_hour)

# calculate base
base_mva=ppc['baseMVA']     # MVA
base_KV=ppc['baseKV']       # KV
base_KA=base_mva/base_KV    # KA
base_Ohm=base_KV/base_KA    # Ohm
base_Siemens=1/base_Ohm     # Siemens



"""
Load data distribution
The load data (active power) is distributed according the static load data of standard IEEE 39-bus.
For now we are not sure this is the way that we want to perform our attack.
"""
# get static load data from standard IEEE 39-bus system (unit: MW/Mvar)
load_p=ppc['bus'][:,2]
load_q=ppc['bus'][:,3]


"""
Convert the generator cost to a simplified version C=A*u + mc*delta_p
"""
p = sy.Symbol('p')
cost_curve={}
cost_curve_diff={}
cost_curve_simple={}
cost_fixed={}
cost_marginal={}
for i in iter_gen:
    cost_curve[i]=ppc["gencost"][i,1]*p**2 + ppc["gencost"][i,2]*p + ppc["gencost"][i,3]
    cost_curve_diff[i]=sy.diff(cost_curve[i],p)
    cost_fixed[i]=cost_curve[i].subs(p, ppc["gen"][i, 9])
    cost_marginal[i]=cost_curve_diff[i].subs(p,(ppc["gen"][i, 8]-ppc["gen"][i, 9])*0.5)
    cost_curve_simple[i]=cost_marginal[i]*(p-ppc["gen"][i, 9])+cost_fixed[i]



"""
Define problem in pyomo
"""
# Define a concrete pyomo model
model = ConcreteModel()
model_at = ConcreteModel()


# ! Note: Variables are defined using iterators, not total numbers
# Variable: generator
model.p1=Var(iter_gen,iter_hour) # Incremental output of generator at Segment 1
model.status=Var(iter_gen, iter_hour, within=Binary) # On-off status

model_at.p1=Var(iter_gen, iter_hour) # Incremental output of generator at Segment 1
model_at.status=Var(iter_gen, iter_hour, within=Binary) # On-off status


# Constraints: generator lower and upper bounds
def con_gen_lower(model,i,t):
    return 0<= model.p1[i,t]
model.con_gen_lower=Constraint(iter_gen,iter_hour,rule=con_gen_lower)
model_at.con_gen_lower=Constraint(iter_gen, iter_hour, rule=con_gen_lower)

def con_gen_upper(model,i,t):
    return model.p1[i,t] <= (ppc["gen"][i,8]-ppc["gen"][i,9])*model.status[i, t]
model.con_gen_upper=Constraint(iter_gen,iter_hour,rule=con_gen_upper)
model_at.con_gen_upper=Constraint(iter_gen, iter_hour, rule=con_gen_upper)


# Network constraints: power balance
def con_balance_normal(model,t):
    return sum(model.p1[i,t]+model.status[i,t]*ppc["gen"][i,9] for i in iter_gen) == PL_norm[t]
model.con_balance=Constraint(iter_hour,rule=con_balance_normal)

# Network constraints: power balance
def con_balance_at(model,t):
    return sum(model.p1[i,t]+model.status[i,t]*ppc["gen"][i,9] for i in iter_gen) == PL_at[t]
model_at.con_balance=Constraint(iter_hour, rule=con_balance_at)



# Objective: minimum cost
def obj_gen_cost(model):
    return sum(sum(model.p1[i,t]*cost_marginal[i]+model.status[i, t]*cost_fixed[i] for t in iter_hour) for i in iter_gen)
model.obj_gen_cost=Objective(rule=obj_gen_cost)
model_at.obj_gen_cost=Objective(rule=obj_gen_cost)

opt = SolverFactory("glpk")
results_normal = opt.solve(model)
results_at = opt.solve(model_at)

"""
Visualize the results
"""
# Export data (pyomo book 173)
# actual power output under normal case
gen_power_normal={}  # create an empty dictionary
for i in iter_gen:
    gen_power_normal[i]=[]   # create an empty list
    for h in iter_hour:
        gen_power_normal[i].append(value(model.p1[i, h]) + value(model.status[i, h]) * ppc["gen"][i, 9])

# actual power output under attack
gen_power_at={}  # create an empty dictionary
for i in iter_gen:
    gen_power_at[i]=[]   # create an empty list
    for h in iter_hour:
        gen_power_at[i].append(value(model_at.p1[i, h]) + value(model_at.status[i, h]) * ppc["gen"][i, 9])



# plot
plt.figure(figsize=(12,5))
plt.xlabel('time (hour)')
plt.ylabel('power (MW)')
plt.plot(PL_norm,'b',linewidth=3,label='Normal')
plt.plot(PL_at,'r',linestyle="--",linewidth=3,label='Attack')
plt.title('Forcasted Load')
plt.legend()
plt.show()


# Plot: 2D
plt.figure(figsize=(12,5))
plt.xlabel('time (hour)')
plt.ylabel('power (MW)')
for i in range(number_gen):
    plt.step(iter_hour, gen_power_normal[i], label='Gen {}'.format(int(ppc["gen"][i, 0])), linewidth=3)
plt.title('UC under Normal Case')
plt.legend(bbox_to_anchor=(1, 1), loc=2, borderaxespad=0.5)
plt.show()


# Plot: 2D
plt.figure(figsize=(12,5))
plt.xlabel('time (hour)')
plt.ylabel('power (MW)')
for i in range(number_gen):
    plt.step(iter_hour, gen_power_at[i], label='Gen {}'.format(int(ppc["gen"][i, 0])), linewidth=3)
plt.title('UC under Cyber Attack')
plt.legend(bbox_to_anchor=(1, 1), loc=2, borderaxespad=0.5)
plt.show()


# # Plot: 3D
# fig = plt.figure(figsize=(12,5))
# ax = fig.add_subplot(111, projection='3d')
# for i in iter_gen:
#     xs = iter_hour
#     ys = gen_power_normal[i]
#     ax.bar(xs, ys, zs=int(ppc["gen"][i,0]), zdir='y', alpha=0.7, label='Gen {}'.format(int(ppc["gen"][i,0])))
# ax.set_xlabel('Hours')
# ax.set_ylabel('Generator Index')
# ax.set_zlabel('Power')
# plt.legend(bbox_to_anchor=(1, 1), loc=2, borderaxespad=0.5)
# plt.show()
# plt.title('UC under Normal Case')
#
# # Plot: 3D
# fig = plt.figure(figsize=(12,5))
# ax = fig.add_subplot(111, projection='3d')
# for i in iter_gen:
#     xs = iter_hour
#     ys = gen_power_at[i]
#     ax.bar(xs, ys, zs=int(ppc["gen"][i,0]), zdir='y', alpha=0.7, label='Gen {}'.format(int(ppc["gen"][i,0])))
# ax.set_xlabel('Hours')
# ax.set_ylabel('Generator Index')
# ax.set_zlabel('Power')
# plt.legend(bbox_to_anchor=(1, 1), loc=2, borderaxespad=0.5)
# plt.show()
# plt.title('UC under Cyber Attack')


